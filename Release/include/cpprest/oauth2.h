/***
* ==++==
*
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* ==--==
* =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
*
* HTTP Library: Oauth 2.0
*
* For the latest on this and related APIs, please see: https://github.com/Microsoft/cpprestsdk
*
* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
****/
#pragma once

#ifndef _CASA_OAUTH2_H
#define _CASA_OAUTH2_H

#include "cpprest/http_client.h"
#include "cpprest/http_msg.h"
#include "cpprest/details/web_utilities.h"

namespace web
{
namespace http
{

class http_pipeline_stage;

/// oAuth 2.0 library.
namespace oauth2
{
namespace details
{

// Constant strings for OAuth 2.0.
typedef utility::string_t oauth2_string;
class oauth2_strings
{
public:
#define _OAUTH2_STRINGS
#define DAT(a_, b_) _ASYNCRTIMP static const oauth2_string a_;
#include "cpprest/details/http_constants.dat"
#undef _OAUTH2_STRINGS
#undef DAT
};

} // namespace web::http::oauth2::details

/// oAuth functionality is currently in beta.
namespace experimental
{

/// <summary>
/// Exception type for OAuth 2.0 errors.
/// </summary>
class oauth2_exception : public std::exception
{
public:
    oauth2_exception(std::string msg) : m_msg(std::move(msg)) {}
    ~oauth2_exception() CPPREST_NOEXCEPT {}
    const char* what() const CPPREST_NOEXCEPT { return m_msg.c_str(); }

private:
    std::string m_msg;
};

/// <summary>
/// OAuth 2.0 token and associated information.
/// </summary>
class oauth2_token
{
public:

    /// <summary>
    /// Value for undefined expiration time in expires_in().
    /// </summary>
    enum { undefined_expiration = -1 };

    oauth2_token(utility::string_t access_token=utility::string_t()) :
        m_access_token(std::move(access_token)),
        m_expires_in(undefined_expiration)
    {}

    /// <summary>
    /// Get access token validity state.
    /// If true, access token is a valid.
    /// </summary>
    /// <returns>Access token validity state.</returns>
    bool is_valid_access_token() const { return !access_token().empty(); }

    /// <summary>
    /// Get access token.
    /// </summary>
    /// <returns>Access token string.</returns>
    const utility::string_t& access_token() const { return m_access_token; }
    /// <summary>
    /// Set access token.
    /// </summary>
    /// <param name="access_token">Access token string to set.</param>
    void set_access_token(utility::string_t access_token) { m_access_token = std::move(access_token); }

    /// <summary>
    /// Get refresh token.
    /// </summary>
    /// <returns>Refresh token string.</returns>
    const utility::string_t& refresh_token() const { return m_refresh_token; }
    /// <summary>
    /// Set refresh token.
    /// </summary>
    /// <param name="refresh_token">Refresh token string to set.</param>
    void set_refresh_token(utility::string_t refresh_token) { m_refresh_token = std::move(refresh_token); }

    /// <summary>
    /// Get token type.
    /// </summary>
    /// <returns>Token type string.</returns>
    const utility::string_t& token_type() const { return m_token_type; }
    /// <summary>
    /// Set token type.
    /// </summary>
    /// <param name="token_type">Token type string to set.</param>
    void set_token_type(utility::string_t token_type) { m_token_type = std::move(token_type); }

    /// <summary>
    /// Get token scope.
    /// </summary>
    /// <returns>Token scope string.</returns>
    const utility::string_t& scope() const { return m_scope; }
    /// <summary>
    /// Set token scope.
    /// </summary>
    /// <param name="scope">Token scope string to set.</param>
    void set_scope(utility::string_t scope) { m_scope = std::move(scope); }

    /// <summary>
    /// Get the lifetime of the access token in seconds.
    /// For example, 3600 means the access token will expire in one hour from
    /// the time when access token response was generated by the authorization server.
    /// Value of undefined_expiration means expiration time is either
    /// unset or that it was not returned by the server with the access token.
    /// </summary>
    /// <returns>Lifetime of the access token in seconds or undefined_expiration if not set.</returns>
    int64_t expires_in() const { return m_expires_in; }
    /// <summary>
    /// Set lifetime of access token (in seconds).
    /// </summary>
    /// <param name="expires_in">Lifetime of access token in seconds.</param>
    void set_expires_in(int64_t expires_in) { m_expires_in = expires_in; }

private:
    utility::string_t m_access_token;
    utility::string_t m_refresh_token;
    utility::string_t m_token_type;
    utility::string_t m_scope;
    int64_t m_expires_in;
};

enum class auth_scheme_t
{
    http_basic,
    request_body
};

class oauth2_client_config
{
public:
    oauth2_client_config(
        web::uri_builder auth_uri, web::http::client::http_client token_client,
        utility::string_t redirect_uri, utility::string_t scope = utility::string_t())
    :
        m_auth_uri(std::move(auth_uri)),
        m_token_client(token_client._get_internal_pipeline()),
        m_redirect_uri(std::move(redirect_uri)),
        m_scope(std::move(scope)),
        m_bearer_auth(true),
        m_auth_scheme(auth_scheme_t::http_basic),
        m_access_token_key(web::http::oauth2::details::oauth2_strings::access_token)
    {}

    /// <summary>
    /// Get the authorization endpoint URI
    /// </summary>
    const uri_builder& auth_uri_builder() const { return m_auth_uri; }

    /// <summary>
    /// Set authorization endpoint URI.
    /// </summary>
    void set_auth_uri_builder(const uri_builder& auth_endpoint) { m_auth_uri = auth_endpoint; }

    /// <summary>
    /// Set the `http_client` used to retrieve new tokens.
    /// To use a proxy when retrieving tokens, configure the `http_client` before assigning it here.
    /// </summary>
    void set_token_client(web::http::client::http_client token_client) { m_token_client = token_client._get_internal_pipeline(); }

    /// <summary>
    /// Internal function to retrieve the `http_client`.
    /// </summary>
    web::http::client::http_client _token_client() const { return web::http::client::http_client(m_token_client); }

    /// <summary>
    /// Get redirect URI string.
    /// </summary>
    /// <returns>Redirect URI string.</returns>
    const utility::string_t& redirect_uri() const { return m_redirect_uri; }

    /// <summary>
    /// Set redirect URI string.
    /// </summary>
    /// <param name="redirect_uri">Redirect URI string to set.</param>
    void set_redirect_uri(utility::string_t redirect_uri) { m_redirect_uri = std::move(redirect_uri); }

    /// <summary>
    /// Get scope used in authorization for token.
    /// </summary>
    /// <returns>Scope string used in authorization.</returns>
    const utility::string_t& scope() const { return m_scope; }
    /// <summary>
    /// Set scope for authorization for token.
    /// </summary>
    /// <param name="scope">Scope string for authorization for token.</param>
    void set_scope(utility::string_t scope) { m_scope = std::move(scope); }

    /// <summary>
    /// Get bearer token authentication setting.
    /// </summary>
    /// <returns>Bearer token authentication setting.</returns>
    bool bearer_auth() const { return m_bearer_auth; }

    /// <summary>
    /// Set bearer token authentication setting.
    /// This must be selected based on what the service accepts.
    /// True means access token is passed in the request header. (http://tools.ietf.org/html/rfc6750#section-2.1)
    /// False means access token in passed in the query parameters. (http://tools.ietf.org/html/rfc6750#section-2.3)
    /// Default: True.
    /// </summary>
    /// <param name="bearer_auth">The bearer token authentication setting to set.</param>
    void set_bearer_auth(bool bearer_auth) { m_bearer_auth = bearer_auth; }

    /// <summary>
    /// Get the configured authentication scheme
    /// </summary>
    auth_scheme_t auth_scheme() const { return m_auth_scheme; }

    /// <summary>
    /// Set authentication scheme used for the token server
    /// </summary>
    /// <remarks>
    /// This setting must be selected based on what the service accepts.
    /// Default: HTTP Basic Authentication
    /// </remarks>
    void set_auth_scheme(auth_scheme_t scheme) { m_auth_scheme = scheme; }

    /// <summary>
    /// Get access token key.
    /// </summary>
    /// <returns>Access token key string.</returns>
    const utility::string_t&  access_token_key() const { return m_access_token_key; }

    /// <summary>
    /// Set access token key.
    /// If the service requires a "non-standard" key you must set it here.
    /// Default: "access_token".
    /// </summary>
    void set_access_token_key(utility::string_t access_token_key) { m_access_token_key = std::move(access_token_key); }

private:
    uri_builder m_auth_uri;
    std::shared_ptr<::web::http::client::http_pipeline> m_token_client;
    utility::string_t m_redirect_uri;
    utility::string_t m_scope;

    bool m_bearer_auth;
    auth_scheme_t m_auth_scheme;
    utility::string_t m_access_token_key;
};

namespace details { class oauth2_client_impl; }



/// <summary>
/// OAuth 2.0 configuration.
///
/// Encapsulates functionality for:
/// -  Authenticating requests with an access token.
/// -  Performing the OAuth 2.0 authorization code grant authorization flow.
///    See: http://tools.ietf.org/html/rfc6749#section-4.1
/// -  Performing the OAuth 2.0 implicit grant authorization flow.
///    See: http://tools.ietf.org/html/rfc6749#section-4.2
///
/// Performing OAuth 2.0 authorization:
/// 1. Set service and client/app parameters:
/// -  Client/app key & secret (as provided by the service).
/// -  The service authorization endpoint and token endpoint.
/// -  Your client/app redirect URI.
/// -  Use set_state() to assign a unique state string for the authorization
///    session (default: "").
/// -  If needed, use set_bearer_auth() to control bearer token passing in either
///    query or header (default: header). See: http://tools.ietf.org/html/rfc6750#section-2
/// -  If needed, use set_access_token_key() to set "non-standard" access token
///    key (default: "access_token").
/// -  If needed, use set_implicit_grant() to enable implicit grant flow.
/// 2. Build authorization URI with build_authorization_uri() and open this in web browser/control.
/// 3. The resource owner should then clicks "Yes" to authorize your client/app, and
///    as a result the web browser/control is redirected to redirect_uri().
/// 5. Capture the redirected URI either in web control or by HTTP listener.
/// 6. Pass the redirected URI to token_from_redirected_uri() to obtain access token.
/// -  The method ensures redirected URI contains same state() as set in step 1.
/// -  In implicit_grant() is false, this will create HTTP request to fetch access token
///    from the service. Otherwise access token is already included in the redirected URI.
///
/// Usage for issuing authenticated requests:
/// 1. Perform authorization as above to obtain the access token or use an existing token.
/// -  Some services provide option to generate access tokens for testing purposes.
/// 2. Pass the resulting oauth2_client_config with the access token to http_client_config::set_oauth2().
/// 3. Construct http_client with this http_client_config. As a result, all HTTP requests
///    by that client will be OAuth 2.0 authenticated.
///
/// </summary>
class oauth2_client
{
public:
    _ASYNCRTIMP oauth2_client();
    _ASYNCRTIMP ~oauth2_client();

    /// <summary>
    /// Get token.
    /// </summary>
    /// <returns>Token.</returns>
    _ASYNCRTIMP oauth2_token token() const;

    /// <summary>
    /// Set token.
    /// </summary>
    /// <param name="tok">Token to set.</param>
    _ASYNCRTIMP void set_token(const oauth2_token& tok);

    /// <summary>
    /// Builds an authorization URI to be loaded in the web browser/view.
    /// </summary>
    /// <remark>
    /// The URI is built with the configuration's auth_uri as basis.
    /// The implicit_grant() affects the built URI by selecting
    /// either authorization code or implicit grant flow.
    /// Use <see cref="nonce_generator::shared_generate"/> to create a secure random string
    /// suitable for use as a state cookie.
    /// </remark>
    /// <example>
    /// <code>
    ///   auto state_cookie = nonce_generator::shared_generate();
    ///   auto auth_uri = my_oauth2_client.build_authorization_uri(state_cookie);
    ///   auto redirect_uri = launch_browser(auth_uri.to_string());
    ///   my_oauth2_client.token_from_redirected_uri(redirect_uri, state_cookie).wait();
    /// </code>
    /// </example>
    _ASYNCRTIMP web::uri auth_code_flow(uri_builder redirect_uri, grant_type grant, const utility::string_t& state_cookie);

    /// <summary>
    /// Sets the internal token by parsing a redirected API and completing the flow if required.
    /// </summary>
    /// <remarks>
    /// If implicit_grant() is false, the URI is parsed for 'code'
    /// parameter, and then token_from_code() is called with this code.
    /// See: http://tools.ietf.org/html/rfc6749#section-4.1
    /// Otherwise, redirect URI fragment part is parsed for 'access_token'
    /// parameter, which directly contains the token(s).
    /// See: http://tools.ietf.org/html/rfc6749#section-4.2
    /// In both cases, the 'state' parameter is parsed and is verified to match state().
    /// </remarks>
    /// <param name="redirected_uri">The URI where web browser/view was redirected after
    /// resource owner's authorization.</param>
    /// <param name="state_cookie">
    /// The same string that was used to call <see cref="build_authorization_uri"/>. This
    /// is checked against the state parameter of the <see cref="redirected_uri"/> and an
    /// exception will be thrown if they are different.
    /// </param>
    /// <returns>A task that will be completed after the internal token field has been set or an error has occurred.</returns>
    _ASYNCRTIMP pplx::task<void> set_token_async_from_redirected_uri(const web::http::uri& redirected_uri, grant_type grant, const utility::string_t& state_cookie);

    /// <summary>
    /// Fetches a token from the token endpoint using an authorization code.
    /// </summary>
    /// <remarks>
    /// Creates an HTTP request to the token endpoint which exchanges
    /// the authorization code for the token(s).
    /// This also sets the refresh token if one was returned.
    /// See: http://tools.ietf.org/html/rfc6749#section-4.1.3
    /// </remarks>
    /// <param name="authorization_code">Code received via redirect upon successful authorization.</param>
    /// <returns>A task that will be completed after the internal token has been set or an error has occurred.</returns>
    _ASYNCRTIMP pplx::task<void> set_token_async_from_code(const utility::string_t& authorization_code);

    /// <summary>
    /// Fetches a new access token (and possibly a new refresh token) using the refresh token.
    /// </summary>
    /// <remarks>
    /// The task creates a HTTP request to the token_endpoint().
    /// If successful, resulting access token is set as active via set_token().
    /// See: http://tools.ietf.org/html/rfc6749#section-6
    /// This also sets a new refresh token if one was returned.
    /// </remarks>
    /// <returns>A task that will be completed after the internal token has been set or an error has occurred.</returns>
    _ASYNCRTIMP pplx::task<void> set_token_async_from_refresh();

    /// <summary>
    /// Performs a custom token request using the provided URI's query component.
    /// </summary>
    /// <remarks>
    /// This function can be used to interact with a nonstandard request flow.
    /// See <see cref="set_token_async_from_refresh"/> and <see cref="set_token_async_from_code"/> for the built-in request flow implementations.
    /// </remarks>
    _ASYNCRTIMP pplx::task<void> set_token_async_from_custom_request(uri_builder request_body);

    /// <summary>
    /// Create a pipeline stage which adds the current `token()` to all http requests.
    /// </summary>
    /// <remarks>
    /// The created pipeline stage shares internal state with this <see cref="oauth2_client"/> object.
    /// To set the token that will be added by the pipeline stage, use the `set_token_XXX()` functions.
    /// </remarks>
    /// <example>
    /// <code>
    ///   my_http_client.add_handler(my_oauth2_client.create_pipeline_stage());
    /// </code>
    /// </example>
    _ASYNCRTIMP std::shared_ptr<http::http_pipeline_stage> create_pipeline_stage();

private:
    std::shared_ptr<details::oauth2_client_impl> m_impl;
};

class oauth2_authorization_code_grant
{
    
};

} // namespace web::http::oauth2::experimental

}}}

#endif
