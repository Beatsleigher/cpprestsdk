/***
* ==++==
*
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* ==--==
* =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
*
* HTTP Library: Oauth 2.0
*
* For the latest on this and related APIs, please see: https://github.com/Microsoft/cpprestsdk
*
* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
****/
#pragma once

#ifndef _CASA_OAUTH2_H
#define _CASA_OAUTH2_H

#include "cpprest/http_client.h"
#include "cpprest/http_msg.h"
#include "cpprest/details/web_utilities.h"
#include "cpprest/details/basic_types.h"

namespace web
{
namespace http
{

class http_pipeline_stage;

/// <summary>
/// APIs to enable OAuth 2.0 integration.
/// See <see cref="oauth2_shared_token"/> for the primary entry points.
/// See the OAuth2Client sample for an example of these APIs in practice.
/// </summary>
namespace oauth2
{
namespace details
{

// Constant strings for OAuth 2.0.
class oauth2_strings
{
public:
#define _OAUTH2_STRINGS
#define DAT(a_, b_) _ASYNCRTIMP static const utility::string_t a_;
#include "cpprest/details/http_constants.dat"
#undef DAT
#undef _OAUTH2_STRINGS
};

} // namespace web::http::oauth2::details

/// <summary>
/// Exception type for OAuth 2.0 errors.
/// </summary>
class oauth2_exception : public std::exception
{
public:
    oauth2_exception(std::string msg) : m_msg(std::move(msg)) {}
    ~oauth2_exception() CPPREST_NOEXCEPT {}
    const char* what() const CPPREST_NOEXCEPT { return m_msg.c_str(); }

private:
    std::string m_msg;
};

/// <summary>
///   OAuth 2.0 token and associated information.
/// </summary>
/// <remarks>
///   This class is not thread safe and is simply a data holder.
///   For integration as an http pipeline stage, see <see cref="oauth2_shared_token"/>.
/// </remarks>
class oauth2_token
{
public:

    /// <summary>
    /// Value for undefined expiration time in expires_in().
    /// </summary>
    enum { undefined_expiration = -1 };

    oauth2_token(utility::string_t access_token=utility::string_t()) :
        m_access_token(std::move(access_token)),
        m_expires_in(undefined_expiration)
    {}

    /// <summary>
    /// Get access token validity.
    /// </summary>
    /// <returns>True if access token is valid for use. False otherwise.</returns>
    bool is_valid_access_token() const { return !access_token().empty(); }

    const utility::string_t& access_token() const { return m_access_token; }
    void set_access_token(utility::string_t access_token) { m_access_token = std::move(access_token); }

    const utility::string_t& refresh_token() const { return m_refresh_token; }
    void set_refresh_token(utility::string_t refresh_token) { m_refresh_token = std::move(refresh_token); }

    const utility::string_t& token_type() const { return m_token_type; }

    /// <summary>
    /// Set token type. Only Bearer tokens are currently supported.
    /// </summary>
    void set_token_type(utility::string_t token_type) { m_token_type = std::move(token_type); }

    const utility::string_t& scope() const { return m_scope; }
    void set_scope(utility::string_t scope) { m_scope = std::move(scope); }

    /// <summary>
    /// Get the lifetime of the access token in seconds.
    /// For example, 3600 means the access token will expire in one hour from
    /// the time when access token response was generated by the authorization server.
    /// Value of <see cref="undefined_expiration"/> means expiration time is either
    /// unset or that it was not returned by the server with the access token.
    /// </summary>
    /// <returns>Lifetime of the access token in seconds or <see cref="undefined_expiration"/> if not set.</returns>
    int64_t expires_in() const { return m_expires_in; }

    /// <summary>
    /// Set lifetime of access token (in seconds).
    /// </summary>
    /// <param name="expires_in">Lifetime of access token in seconds.</param>
    void set_expires_in(int64_t expires_in) { m_expires_in = expires_in; }

private:
    utility::string_t m_access_token;
    utility::string_t m_refresh_token;
    utility::string_t m_token_type;
    utility::string_t m_scope;
    int64_t m_expires_in;
};

namespace details
{
class oauth2_shared_token_impl;
class grant_flow;
}

/// <summary>
///   Specifies the mechanism to communicate the client credentials.
/// </summary>
/// <remarks>
///   See [RFC 6749 Section 2.3.1](https://tools.ietf.org/html/rfc6749#section-2.3.1)
/// </remarks>
enum class client_credentials_mode
{
    /// <summary>Add the client credentials using HTTP Basic Auth</summary>
    http_basic_auth,
    /// <summary>Add the client credentials to the request body as client_id=AAA&client_secret=BBB</summary>
    request_body,
    /// <summary>Do not add the client credentials to the request. Rely on the <see cref="client::http_client"/>'s authentication machinery.</summary>
    none
};

/// <summary>
/// A thread-safe OAuth2 token with `std::shared_ptr` semantics.
/// </summary>
/// <remarks>
///   To create a new token, see the flow factories:
///   * <see cref="auth_code_grant_flow" />
///   * <see cref="implicit_grant_flow" />
///   * <see cref="resource_owner_creds_grant_flow" />
///   * <see cref="extension_grant_flow" />
///   For integration as an <see cref="http_pipeline_stage"/>, see <see cref="create_pipeline_stage"/>.
/// </remarks>
class oauth2_shared_token
{
public:
    /// <summary>
    ///   Allocates a new <see cref="oauth2_token"/> with `std::shared_ptr` semantics.
    /// </summary>
    /// <param name="token">
    ///   Value to initialize internal <see cref="oauth2_token"/> with. Optional.
    /// </param>
    _ASYNCRTIMP explicit oauth2_shared_token(const oauth2_token& token = oauth2_token());
    _ASYNCRTIMP ~oauth2_shared_token();

    /// <summary>
    /// Get a copy of the shared token. Thread-safe.
    /// </summary>
    _ASYNCRTIMP oauth2_token token() const;

    /// <summary>
    /// Set the shared token. Thread-safe.
    /// </summary>
    _ASYNCRTIMP void set_token(const oauth2_token& tok);

    /// <summary>
    ///   Sets the internal shared token according to the Extension Grant Flow. See <see cref="extension_grant_flow"/>.
    /// </summary>
    _ASYNCRTIMP pplx::task<void> set_token_via_extension_grant(
        web::uri_builder request_body,
        web::http::client::http_client token_client,
        const utility::string_t& scope = utility::string_t(),
        client_credentials_mode creds_mode = client_credentials_mode::http_basic_auth);

    /// <summary>
    ///   Refresh the internal access token using the stored refresh token.
    /// </summary>
    /// <remarks>
    ///   Some OAuth2 flows result in a refresh token being provided to the client, such as the <see cref="auth_code_grant_flow">Authorization Code Flow</see>.
    ///   See [RFC 6749 Section 6](https://tools.ietf.org/html/rfc6749#section-6).
    /// </remarks>
    /// <param name="token_client">
    ///   Specifies the <see cref="client::http_client"/> that will be used to request an access token from the grant information.
    ///   Authentication will be performed with the credentials stored in <see cref="client::http_client::client_config()"/>.
    /// </param>
    /// <param name="scope">
    ///   Specifies the requested permissions scope for the new access token.
    ///   If empty, requests the same scope as the current access token.
    ///   Defaults to empty string.
    /// </param>
    /// <param name="creds_mode">
    ///   Specifies the mechanism used to authenticate with the <paramref name="token_client"/>.
    ///   See <see cref="client_credentials_mode" /> for more details.
    ///   Defaults to HTTP Basic Auth.
    /// </param>
    /// <returns>
    ///   A task which completes with `void` when the new access token has been successfully acquired or with a `std::exception` describing the failure.
    /// </returns>
    _ASYNCRTIMP pplx::task<void> set_token_via_refresh_token(
        web::http::client::http_client token_client,
        const utility::string_t& scope = utility::string_t(),
        client_credentials_mode creds_mode = client_credentials_mode::http_basic_auth);

    /// <summary>
    ///   Create a pipeline stage which adds the shared `token()` to all http requests.
    /// </summary>
    /// <remarks>
    ///   The created pipeline stage shares internal state with this <see cref="oauth2_shared_token"/> object.
    ///   To set the token that will be added by the pipeline stage, use the `set_token_XXX()` functions.
    /// </remarks>
    /// <param name="access_token_key">
    ///   If empty, specifies that the access token should be added to the HTTP Authorization header according to the token type.
    ///   If non-empty, specifies that the access token should be appended to requests' query parameters and
    ///   specifies which key name will be used.
    ///   Defaults to empty string.
    ///   See [RFC 6749 Section 7.1](https://tools.ietf.org/html/rfc6749#section-7.1).
    /// </param>
    /// <example>
    /// <code>
    ///   my_http_client.add_handler(my_oauth2_shared_token.create_pipeline_stage());
    /// </code>
    /// </example>
    _ASYNCRTIMP std::shared_ptr<http::http_pipeline_stage> create_pipeline_stage(
        const utility::string_t& access_token_key = utility::string_t());

private:
    std::shared_ptr<details::oauth2_shared_token_impl> m_impl;
};

/// <summary>
///   Encapsulates the state information for the OAuth2 Authorization Code Grant Flow.
/// </summary>
/// <remarks>
///   The User must be redirected to the URI returned from <see cref="auth_code_grant_flow::uri"/>.
///   Once authenticated, they will be redirected to the stored `base_redirect_uri` with an
///   authorization code which can be exchanged for an access token via the
///   <see cref="auth_code_grant_flow::complete"/> function.
///   See [RFC 6749 Section 4.1](https://tools.ietf.org/html/rfc6749#section-4.1).
///
///   *Note: This grant flow should only be used in confidential clients (such as on a web server you control) and not in a native client app.
///   The equivalent flow for native client apps is the Implicit Grant Flow: <see cref="implicit_grant_flow"/>.*
/// </remarks>
/// <example>
/// <code>
///   auto flow = oauth2_shared_token::auth_code_grant_flow(
///       my_client_id,
///       U("https://login.live.com/oauth20_authorize.srf"),
///       U("https://localhost/"),
///       U("wl.basic"));
///   auto redirect_uri = redirect_user_async(flow.uri().to_string()).get();
///   http_client_config token_client_config;
///   token_client_config.set_credentials(web::credentials(my_client_id, my_client_secret));
///   http_client token_client(U("https://login.live.com/oauth20_token.srf"), config);
///   auto my_oauth2_shared_token = flow.complete(redirect_uri, token_client).get();
/// </code>
/// </example>
class auth_code_grant_flow
{
public:
    /// <param name="client_id">Specifies the client's identity.</param>
    /// <param name="auth_endpoint">Specifies the OAuth2 provider's authorization landing page.</param>
    /// <param name="base_redirect_uri">Specifies the URI users will be redirected to, with the authorization code appended.</param>
    /// <param name="scope">Specifies the requested access scope. Defaults to empty string.</param>
    _ASYNCRTIMP auth_code_grant_flow(
        const utility::string_t& client_id,
        const web::uri_builder& auth_endpoint,
        const web::uri& base_redirect_uri,
        const utility::string_t& scope = utility::string_t()
    );
    _ASYNCRTIMP ~auth_code_grant_flow();

    /// <returns>
    ///   A uri for the OAuth2 service's authorization page.
    /// </returns>
    /// <remarks>
    ///   The user's browser should be redirected to this URI to authorize your use of the OAuth2 protected resources.
    /// </remarks>
    _ASYNCRTIMP web::uri uri() const;
    /// <summary>
    ///   Complete the Authorization Code Grant Flow by passing the authorization code to the token server in exchange for the final access token.
    /// </summary>
    /// <param name="token_client">Specifies the <see cref="http_client"/> used to exchange the authorization code for an access token.</param>
    /// <param name="creds_mode">
    ///   Specifies the mechanism to transfer the client's credentials to the token server.
    ///   Defaults to HTTP Basic Auth.
    ///   See <see cref="client_credentials_mode"/> for more details.
    /// </param>
    /// <returns>
    ///   A task which completes with an initialized <see cref="oauth2_shared_token"/> when the
    ///   new access token has been successfully acquired or with a `std::exception` describing the failure.
    /// </returns>
    _ASYNCRTIMP pplx::task<oauth2_shared_token> complete(
        const web::uri& redirected_uri,
        web::http::client::http_client token_client,
        client_credentials_mode creds_mode = client_credentials_mode::http_basic_auth) const;

private:
    std::shared_ptr<const details::grant_flow> m_impl;
};

/// <summary>
///   Encapsulates the state information for the OAuth2 Implicit Grant Flow.
/// </summary>
/// <remarks>
///   The URI returned from <see cref="implicit_grant_flow::uri"/> needs to be opened in a WebView or equivalent widget for the user to authenticate.
///   Once authenticated, the WebView will be redirected to the stored `base_redirect_uri` with the token information.
///   This redirected uri can be parsed and validated with the <see cref="implicit_grant_flow::complete"/> function.
///   See [RFC 6749 Section 4.2](https://tools.ietf.org/html/rfc6749#section-4.2).
/// </remarks>
/// <example>
/// <code>
///   auto flow = oauth2_shared_token::implicit_grant_flow(
///       my_client_id,
///       U("https://login.live.com/oauth20_authorize.srf"),
///       U("https://localhost/"),
///       U("wl.basic"));
///   auto redirect_uri = launch_browser_async(flow.uri().to_string()).get();
///   auto my_oauth2_shared_token = flow.complete(redirect_uri);
/// </code>
/// </example>
class implicit_grant_flow
{
public:
    /// <param name="client_id">Specifies the client's identity.</param>
    /// <param name="auth_endpoint">Specifies the OAuth2 provider's authorization landing page.</param>
    /// <param name="base_redirect_uri">Specifies the URI users will be redirected to, with the authorization code appended.</param>
    /// <param name="scope">Specifies the requested access scope. Defaults to empty string.</param>
    _ASYNCRTIMP implicit_grant_flow(
        const utility::string_t& client_id,
        const web::uri_builder& auth_endpoint,
        const web::uri& base_redirect_uri,
        const utility::string_t& scope = utility::string_t()
    );

    _ASYNCRTIMP ~implicit_grant_flow();

    /// <returns>
    ///   A uri for the OAuth2 service's authorization page.
    /// </returns>
    /// <remarks>
    ///   The user's browser should be redirected to this URI to authorize your use of the OAuth2 protected resources.
    /// </remarks>
    _ASYNCRTIMP web::uri uri() const;

    /// <summary>
    ///   Complete the Implicit Grant Flow by parsing and validating the access token from the redirected URI.
    /// </summary>
    /// <returns>A fresh, validated <see cref="oauth2_shared_token"/>.</returns>
    /// <exception cref="std::exception">Thrown if an error occurs during parsing or validation.</exception>
    _ASYNCRTIMP oauth2_shared_token complete(const web::uri& redirected_uri) const;

private:
    std::shared_ptr<const details::grant_flow> m_impl;
};

/// <summary>
///   Use the Resource Owner Credentials Grant flow to initialize a new <see cref="oauth2_shared_token"/>.
/// </summary>
/// <remarks>
///   The Resource Owner Password Credentials Grant flow is suitable in
///   cases where the resource owner has a trust relationship with the
///   client, such as the device operating system or a highly privileged
///   application.
///   See [RFC 6749 Section 4.3](https://tools.ietf.org/html/rfc6749#section-4.3).
/// </remarks>
/// <param name="token_client">
///   Specifies the <see cref="client::http_client"/> that will be used to request an access token from the grant information.
///   Authentication will be performed with the credentials stored in <see cref="client::http_client::client_config()"/>.
/// </param>
/// <param name="owner_credentials">
///   Specifies the user's username and password.
///   Once this function returns, the program's copy of the credentials
///   should be disposed of as quickly as possible to minimize exposure.
/// </param>
/// <param name="scope">
///   Specifies the requested permissions scope for the new access token.
///   If empty, requests the same scope as the current access token.
///   Defaults to empty string.
/// </param>
/// <param name="creds_mode">
///   Specifies the mechanism used to authenticate with the <paramref name="token_client"/>.
///   See <see cref="client_credentials_mode" /> for more details.
///   Defaults to HTTP Basic Auth.
/// </param>
/// <returns>
///   A task which completes with `void` when the new access token has been successfully acquired or with a `std::exception` describing the failure.
/// </returns>
_ASYNCRTIMP pplx::task<oauth2_shared_token> __cdecl resource_owner_creds_grant_flow(
    web::http::client::http_client token_client,
    const web::credentials& owner_credentials,
    const utility::string_t& scope = utility::string_t(),
    client_credentials_mode creds_mode = client_credentials_mode::http_basic_auth);

/// <summary>
///   Use the Extension Grant flow to initialize a new <see cref="oauth2_shared_token"/>.
/// </summary>
/// <remarks>
///   The OAuth2 specification describes an Extension Grant mechanism for providers to plug in custom grants.
///   See [RFC 6749 Section 4.5](https://tools.ietf.org/html/rfc6749#section-4.5).
/// </remarks>
/// <param name="token_client">
///   Specifies the <see cref="client::http_client"/> that will be used to request an access token from the grant information.
///   Authentication will be performed with the credentials stored in <see cref="client::http_client::client_config()"/>.
/// </param>
/// <param name="scope">
///   Specifies the requested permissions scope for the new access token.
///   If empty, requests the same scope as the current access token.
///   Defaults to empty string.
/// </param>
/// <param name="creds_mode">
///   Specifies the mechanism used to authenticate with the <paramref name="token_client"/>.
///   See <see cref="client_credentials_mode" /> for more details.
///   Defaults to HTTP Basic Auth.
/// </param>
/// <returns>
///   A task which completes with `void` when the new access token has been successfully acquired or with a `std::exception` describing the failure.
/// </returns>
_ASYNCRTIMP pplx::task<oauth2_shared_token> __cdecl extension_grant_flow(
    web::uri_builder request_body,
    web::http::client::http_client token_client,
    const utility::string_t& scope = utility::string_t(),
    client_credentials_mode creds_mode = client_credentials_mode::http_basic_auth);

}}} // namespace web::http::oauth2

#endif
